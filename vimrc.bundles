"----------------------------------------------------------------
" Loading plugins
"----------------------------------------------------------------
call plug#begin('~/.vim/bundle')

" auto completion (depending on OS type)
if has('neovim')
    Plug 'ervandew/supertab'
elseif has("win32") || has("win64") || has("win32unix")
    Plug 'Shougo/neocomplete.vim'
    Plug 'Shougo/neosnippet.vim'
    Plug 'Shougo/neosnippet-snippets'
elseif has('unix')
    Plug 'Valloric/YouCompleteMe', {'dir': '~/.vim.local/bundle/YouCompleteMe'}
    Plug 'SirVer/ultisnips'
    Plug 'honza/vim-snippets'
endif

" cooperation with vimux (in gui only)
if !has('gui_running')
    Plug 'benmills/vimux'
endif

Plug 'tpope/vim-fugitive', {'branch/tag': 'master/v2.0'}
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-commentary'
Plug 'scrooloose/nerdtree', {'on': ['NERDTreeToggle', 'NERDTreeFind', 'NERDTreeFromBookmark', 'NERDTreeCWD']}
Plug 'airblade/vim-gitgutter'
Plug 'bling/vim-airline'
Plug 'majutsushi/tagbar'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'scrooloose/syntastic'

" depending on filetypes
Plug 'tpope/vim-fireplace', {'for': 'clojure'}
Plug 'plasticboy/vim-markdown', {'for': 'mkd'}
Plug 'derekwyatt/vim-scala', {'for': 'scala', 'on': 'SortScalaImports'}
Plug 'derekwyatt/vim-sbt', {'for': 'sbt'}
Plug 'dag/vim2hs', {'for': 'haskell'}

" colorschemes
Plug 'altercation/vim-colors-solarized'

" Plug 'tacahiroy/ctrlp-funky', {
"     \ 'depends' : ['ctrlpvim/ctrlp.vim'],
"     \ 'autoload' : {
"     \  'commands' : ['CtrlPFunky']
"     \ }}

" Plug 'Shougo/unite.vim'
" Plug 'Shougo/neomru.vim'
" Plug 'Shougo/unite-outline'
" Plug 'Shougo/vimproc.vim', {'dir': '~/.vim.local/bundle/vimproc.vim'}

" Plug 'vim-scripts/AutoComplPop'

" Plug 'scrooloose/nerdcommenter'

" Plug 'Raimondi/delimitMate'

" Plug 'mikewest/vimroom'

" Plug 'Lokaltog/vim-easymotion'

" Plug 'nathanaelkane/vim-indent-guides'

" Plug 'godlygeek/tabular', {
"     \ 'autoload' : {
"     \  'commands' : ['Tabularize']
"     \ }}

" Plug 'itchyny/lightline.vim'

" Plug 'terryma/vim-multiple-cursors'

" Plug 'mhinz/vim-startify'

" Plug 'tomasr/molokai'

call plug#end()

"----------------------------------------------------------------
" fugitive
"----------------------------------------------------------------
autocmd QuickFixCmdPost *grep* cwindow
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gg :Ggrep<Space>
nnoremap <Leader>gc :Gcommit -m ''<Left>
nnoremap <Leader>gr :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gl :Glog<CR>

"----------------------------------------------------------------
" ctrlp
"----------------------------------------------------------------
if has('python')
    let g:ctrlp_match_func = {'match': 'pymatcher#PyMatch'}
endif
let g:ctrlp_cmd = 'CtrlP .'
let g:ctrlp_working_path_mode='ra'
let g:ctrlp_by_filename = 1
if executable('ag')
    let g:ctrlp_user_command = 'ag --follow --nocolor -g "" %s'
elseif executable('git')
    let g:ctrlp_user_command = 'git ls-files . --cached --exclude-standard --others'
else
    let g:ctrlp_custom_ignore = {
        \ 'dir': 'assets$\|action_log$\|\.gradle$\|build$\|project$\|target$\|out$\|libs$\|\.git$',
        \ 'link': 'SOME_BAD_SYMBOLIC_LINKS'
    \ }
endif
let g:ctrlp_show_hidden = 1
let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:20'
nnoremap <silent> <Space>p :CtrlP .<CR>
nnoremap <silent> <Space>b :CtrlPBuffer<CR>
nnoremap <silent> <Space>m :CtrlPMRU<CR>
nnoremap <silent> <Space>l :CtrlPLine %<CR>
nnoremap <silent> <Space>u :CtrlPUndo<CR>
" nnoremap <silent> <Space>r :CtrlPFunky<CR>

"----------------------------------------------------------------
" unite
"----------------------------------------------------------------
"let g:unite_enable_start_insert = 1
"let g:unite_source_history_yank_enable = 1
"let g:unite_source_file_mru_limit = 200
"if executable('ag')
    "let g:unite_source_rec_async_command =
    "\ 'ag --follow --nocolor --nogroup --hidden -g ""'
"elseif executable('git')
    "let g:unite_source_rec_async_command =
    "\ 'git ls-files . --cached --exclude-standard --others'
"endif
"nnoremap <Space>p :Unite file_rec/git:--cached:--others:--exclude-standard<CR>
""nnoremap <Space>p :Unite file_rec/async<CR>
"nnoremap <Space>b :Unite buffer<CR>
"nnoremap <Space>c :Unite command<CR>
"nnoremap <Space>s :Unite source<CR>
"nnoremap <Space>f :Unite function<CR>
"nnoremap <Space>m :Unite file_mru<CR>
"nnoremap <Space>l :Unite line<CR>
"nnoremap <Space>y :Unite history/yank<CR>
"nnoremap <Space>h :Unite change<CR>
"nnoremap <Space>n :Unite neobundle<CR>
"nnoremap <Space>r :Unite outline<CR>
"nnoremap <Space>j :Unite jump<CR>
"nnoremap <Space>k :Unite mapping<CR>

"----------------------------------------------------------------
" syntastic
"----------------------------------------------------------------
let g:syntastic_mode_map = { "mode": "passive",
                        \ "active_filetypes": [],
                        \ "passive_filetypes": [] }
let g:syntastic_check_on_open = 1
let g:syntastic_enable_signs = 1
nnoremap <silent> <Leader>si :SyntasticInfo<CR>
nnoremap <silent> <Leader>sc :SyntasticCheck<CR>

"----------------------------------------------------------------
" nerdtree
"----------------------------------------------------------------
nnoremap <silent> <Leader>nt :NERDTreeToggle<CR>
nnoremap <silent> <Leader>nf :NERDTreeFind<CR>
nnoremap <silent> <Leader>nm :NERDTreeMirror<CR>
nnoremap <silent> <Leader>nb :NERDTreeFromBookmark<CR>
nnoremap <silent> <Leader>nc :NERDTreeCWD<CR>

"----------------------------------------------------------------
" vimux
"----------------------------------------------------------------
nnoremap <silent> <Leader>vp :wa<CR>:VimuxPromptCommand<CR>
nnoremap <silent> <Leader>vl :wa<CR>:VimuxRunLastCommand<CR>
nnoremap <silent> <Leader>vi :VimuxInspectRunner<CR>
nnoremap <silent> <Leader>vq :VimuxCloseRunner<CR>
nnoremap <silent> <Leader>vs :VimuxInterruptRunner<CR>
nnoremap <silent> <Leader>vz :VimuxZoomRunner<CR>
nnoremap <silent> <Leader>vo :call VimuxOpenRunnerAtCWD()<CR>
nnoremap <silent> <Leader>vh :silent !tmux resize-pane -Z<CR>
function! VimuxOpenRunnerAtCWD()
    let cwd = getcwd()
    exe "normal! :VimuxRunCommand(\"" . cwd . "\")\<CR>"
endfunction

" aliases for sbt commands
nnoremap <silent> <Leader>vc :wa<CR>:VimuxRunCommand("compile")<CR>
nnoremap <silent> <Leader>vr :wa<CR>:VimuxRunCommand("run")<CR>
nnoremap <silent> <Leader>vt :call VimuxRunTest()<CR>

let g:lasttest = ""

function! VimuxRunTest()
    exe "normal! :wa\<CR>"
    let l:name = expand("%:t:r")
    let l:command = ""
    if l:name =~# "\.\*Test"
        let g:lasttest = l:name
        let l:command = "test:testOnly *" . l:name
    else
        let l:command = "test:testOnly *" . g:lasttest
    endif
    exe "normal! :call VimuxRunCommand(\"" . l:command . "\")\<CR>"
endfunction

"----------------------------------------------------------------
" easymotion
"----------------------------------------------------------------
" map s <Plug>(easymotion-prefix)
" let g:EasyMotion_smartcase = 1

"----------------------------------------------------------------
" indent-guides
"----------------------------------------------------------------
" let g:indent_guides_enable_on_vim_startup = 1
" let g:indent_guides_start_level = 2
" let g:indent_guides_guide_size = 1

"----------------------------------------------------------------
" tagbar
"----------------------------------------------------------------
let g:tagbar_type_scala = {
    \ 'ctagstype' : 'Scala',
    \ 'kinds'     : [
        \ 'p:packages:1',
        \ 'V:values',
        \ 'v:variables',
        \ 'T:types',
        \ 't:traits',
        \ 'o:objects',
        \ 'a:aclasses',
        \ 'c:classes',
        \ 'r:cclasses',
        \ 'm:methods'
    \ ]
\ }
nnoremap <F9> :TagbarToggle<CR>

"----------------------------------------------------------------
" lightline
"----------------------------------------------------------------
"let g:lightline = {
      "\ 'colorscheme': 'solarized',
      "\ 'active': {
      "\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      "\   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      "\ },
      "\ 'component_function': {
      "\   'fugitive': 'MyFugitive',
      "\   'filename': 'MyFilename',
      "\   'fileformat': 'MyFileformat',
      "\   'filetype': 'MyFiletype',
      "\   'fileencoding': 'MyFileencoding',
      "\   'mode': 'MyMode',
      "\   'ctrlpmark': 'CtrlPMark',
      "\ },
      "\ 'component_expand': {
      "\   'syntastic': 'SyntasticStatuslineFlag',
      "\ },
      "\ 'component_type': {
      "\   'syntastic': 'error',
      "\ },
      "\ 'subseparator': { 'left': '|', 'right': '|' }
      "\ }

"function! MyModified()
  "return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
"endfunction

"function! MyReadonly()
  "return &ft !~? 'help' && &readonly ? 'RO' : ''
"endfunction

"function! MyFilename()
  "let fname = expand('%:t')
  "return fname == 'ControlP' ? g:lightline.ctrlp_item :
        "\ fname == '__Tagbar__' ? g:lightline.fname :
        "\ fname =~ '__Gundo\|NERD_tree' ? '' :
        "\ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        "\ &ft == 'unite' ? unite#get_status_string() :
        "\ &ft == 'vimshell' ? vimshell#get_status_string() :
        "\ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        "\ ('' != fname ? fname : '[No Name]') .
        "\ ('' != MyModified() ? ' ' . MyModified() : '')
"endfunction

"function! MyFugitive()
  "try
    "if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      "let mark = ''  " edit here for cool mark
      "let _ = fugitive#head()
      "return strlen(_) ? mark._ : ''
    "endif
  "catch
  "endtry
  "return ''
"endfunction

"function! MyFileformat()
  "return winwidth(0) > 70 ? &fileformat : ''
"endfunction

"function! MyFiletype()
  "return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
"endfunction

"function! MyFileencoding()
  "return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
"endfunction

"function! MyMode()
  "let fname = expand('%:t')
  "return fname == '__Tagbar__' ? 'Tagbar' :
        "\ fname == 'ControlP' ? 'CtrlP' :
        "\ fname == '__Gundo__' ? 'Gundo' :
        "\ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        "\ fname =~ 'NERD_tree' ? 'NERDTree' :
        "\ &ft == 'unite' ? 'Unite' :
        "\ &ft == 'vimfiler' ? 'VimFiler' :
        "\ &ft == 'vimshell' ? 'VimShell' :
        "\ winwidth(0) > 60 ? lightline#mode() : ''
"endfunction

"function! CtrlPMark()
  "if expand('%:t') =~ 'ControlP'
    "call lightline#link('iR'[g:lightline.ctrlp_regex])
    "return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          "\ , g:lightline.ctrlp_next], 0)
  "else
    "return ''
  "endif
"endfunction

"let g:ctrlp_status_func = {
  "\ 'main': 'CtrlPStatusFunc_1',
  "\ 'prog': 'CtrlPStatusFunc_2',
  "\ }

"function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  "let g:lightline.ctrlp_regex = a:regex
  "let g:lightline.ctrlp_prev = a:prev
  "let g:lightline.ctrlp_item = a:item
  "let g:lightline.ctrlp_next = a:next
  "return lightline#statusline(0)
"endfunction

"function! CtrlPStatusFunc_2(str)
  "return lightline#statusline(0)
"endfunction

"let g:tagbar_status_func = 'TagbarStatusFunc'

"function! TagbarStatusFunc(current, sort, fname, ...) abort
    "let g:lightline.fname = a:fname
  "return lightline#statusline(0)
"endfunction

"augroup AutoSyntastic
  "autocmd!
  "autocmd BufWritePost *.c,*.cpp call s:syntastic()
"augroup END
"function! s:syntastic()
  "SyntasticCheck
  "call lightline#update()
"endfunction

"let g:unite_force_overwrite_statusline = 0
"let g:vimfiler_force_overwrite_statusline = 0
"let g:vimshell_force_overwrite_statusline = 0

"----------------------------------------------------------------
" airline
"----------------------------------------------------------------
let g:airline_theme = "solarized"
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#show_tab_nr = 1
let g:airline#extensions#tabline#tab_nr_type = 1
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#tabline#buffer_idx_mode = 1
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9

"----------------------------------------------------------------
" multiple-cursors
"----------------------------------------------------------------
" function! Multiple_cursors_before()
"     if exists(':NeoCompleteLock')==2
"         exe 'NeoCompleteLock'
"     endif
" endfunction
" function! Multiple_cursors_after()
"     if exists(':NeoCompleteUnlock')==2
"         exe 'NeoCompleteUnlock'
"     endif
" endfunction

"----------------------------------------------------------------
" solarized
"----------------------------------------------------------------
let g:solarized_termcolors=256
let g:solarized_visibility='high'
let g:solarized_hitrail=1
let g:solarized_termtrans=1

"----------------------------------------------------------------
" vim-scala
"----------------------------------------------------------------
nnoremap <silent> <Leader>ss :SortScalaImports<CR>
let g:scala_sort_across_groups=0

"----------------------------------------------------------------
" neocomplete
"----------------------------------------------------------------
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_auto_delimiter = 0
let g:neocomplete#sources#syntax#min_keyword_length = 4
let g:neocomplete#auto_completion_start_length = 2
if !exists('g:neocomplete#sources')
    let g:neocomplete#sources = {}
endif
let g:neocomplete#sources._ = ['buffer', 'neosnippet']
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"

"----------------------------------------------------------------
" neosnippet
"----------------------------------------------------------------
imap <c-k> <Plug>(neosnippet_expand_or_jump)
smap <c-k> <Plug>(neosnippet_expand_or_jump)
xmap <c-k> <Plug>(neosnippet_expand_target)
let g:neosnippet#snippets_directory = '~/.vim/bundle/neosnippet-snippets/neosnippets'
"imap <expr><tab> neosnippet#expandable_or_jumpable() ?
            "\ "\<Plug>(neosnippet_expand_or_jump)"
            "\: pumvisible() ? "\<c-n>" : "\<tab>"
"smap <expr><tab> neosnippet#expandable_or_jumpable() ?
            "\ "\<Plug>(neosnippet_expand_or_jump)"
            "\: "\<tab>"

"----------------------------------------------------------------
" ultisnips
"----------------------------------------------------------------
let g:UltiSnipsExpandTrigger="<c-cr>"
let g:UltiSnipsListSnippets="<c-tab>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsSnippetsDir="~/.vim.local/bundle/vim-snippets/UltiSnips"

"----------------------------------------------------------------
" startify
"----------------------------------------------------------------
" let g:startify_enable_special         = 0
" let g:startify_files_number           = 8
" let g:startify_relative_path          = 1
" let g:startify_change_to_dir          = 0
" let g:startify_session_autoload       = 1
" let g:startify_session_persistence    = 1
" let g:startify_session_delete_buffers = 1

" let g:startify_list_order = [
"   \ ['   LRU within this dir:'],
"   \ 'dir',
"   \ ['   LRU:'],
"   \ 'files',
"   \ ['   Sessions:'],
"   \ 'sessions',
"   \ ['   Bookmarks:'],
"   \ 'bookmarks',
"   \ ]

" let g:startify_skiplist = [
"             \ 'COMMIT_EDITMSG',
"             \ $VIMRUNTIME .'/doc',
"             \ 'bundle/.*/doc',
"             \ '\.vimgolf',
"             \ ]

" let g:startify_bookmarks = [
"             \ '~/.vimrc',
"             \ ]

" " let g:startify_custom_footer =
" "       \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

" let g:startify_custom_header =
"       \ map(split(system('tips | cowsay -f apt'), '\n'), '"   ". v:val') + ['']

" hi StartifyBracket ctermfg=240
" hi StartifyFile    ctermfg=147
" hi StartifyFooter  ctermfg=240
" hi StartifyHeader  ctermfg=114
" hi StartifyNumber  ctermfg=215
" hi StartifyPath    ctermfg=245
" hi StartifySlash   ctermfg=240
" hi StartifySpecial ctermfg=240

" nnoremap [Leader]s :Startify<CR>

"----------------------------------------------------------------
" foldElse (original plugin)
"----------------------------------------------------------------
" let s:pattern = ""
" "useful unfolding mapping
" nnoremap <Leader>fu zE

" nnoremap <Leader>fl :call FoldElseLastPattern()<CR>
" function! FoldElseLastPattern()
"     exe ":normal! :call FoldElse(\"" . s:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>fc :call FoldElseClass()<CR>
" function! FoldElseClass()
"     let l:pattern = "\\\\sclass\\\\s"
"     let s:pattern = l:pattern
"     exe ":normal! :call FoldElse(\"" . l:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>ff :call FoldElseFunc()<CR>
" function! FoldElseFunc()
"     let l:pattern = "\\\\sdef\\\\s"
"     let s:pattern = l:pattern
"     exe ":normal! :call FoldElse(\"" .l:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>fp :call FoldElsePrompt()<CR>
" function! FoldElsePrompt()
"     let l:pattern = input("Pattern? ")
"     let s:pattern = l:pattern
"     exe "normal! :call FoldElse(\"" . l:pattern . "\")\<CR>"
" endfunction

" function! FoldElse(pattern)
"     set foldopen-=search
"     if search(a:pattern)
"         exe "normal! zEgg"
"         let l:flag = 0
"         let l:start_line_number = 0
"         while 1
"             let l:line_number = search(a:pattern, 'W')
"             if l:line_number == 0
"                 let l:line_number = line('$') + 1
"                 let l:flag = 1
"             endif
"             let l:end_line_number = l:line_number - 1
"             exe "normal! :" . l:start_line_number . "," . l:end_line_number . "fold\<CR>"
"             let l:start_line_number = l:line_number + 1
"             exe "normal! j"
"             if l:flag
"                 break
"             endif
"         endwhile
"         exe "normal! /" . a:pattern . "\<CR>"
"     endif
" endfunction

"----------------------------------------------------------------
" colorscheme
"----------------------------------------------------------------
if $COLORTERM == 'gnome-terminal'
    set t_Co=256
endif
if has("gui_running")
    set background=dark
else
    set background=dark
endif
colorscheme solarized
