"----------------------------------------------------------------
" Loading plugins
"----------------------------------------------------------------
" If using Windows Vim, you should manually add .vim directory to runtime path.
if has("win32") || has("win64")
    set runtimepath+=~/.vim/
endif

call plug#begin('~/.vim/bundle')

" auto completion (depending on OS type)
" snippets are not useful because you need to remembar keywords
if (has("win32") || has("win64") || has("win32unix")) && has("lua")
    Plug 'Shougo/neocomplete.vim'
    Plug 'Shougo/neosnippet.vim'
    Plug 'Shougo/neosnippet-snippets'
elseif has('unix') && has("python")
    Plug 'Valloric/YouCompleteMe'
    Plug 'SirVer/ultisnips'
    " my fork repository to power scala support.
    Plug 'iwataka/vim-snippets'
else
    Plug 'ervandew/supertab'
endif

" cooperation with vimux (in gui only)
if !has('gui_running')
    Plug 'benmills/vimux'
    Plug 'christoomey/vim-tmux-navigator'
endif

" This plugin is unstable with nerdtree.
Plug 'tpope/vim-fugitive'

" Save the time to add close brackets.
Plug 'Raimondi/delimitMate'

" ctrlp and fast matcher
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'iwataka/ctrlproj.vim'

" useful key-mappings
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-commentary'

" motion helper
Plug 'haya14busa/incsearch.vim'

" display useful information
Plug 'airblade/vim-gitgutter'
Plug 'bling/vim-airline'
Plug 'majutsushi/tagbar'

" Currently unused

" Unix is faster than Windows.
if !has('win32') && !has('win64') && !has('win32unix')
    " easymotion use unpredictable keys
    " Plug 'Lokaltog/vim-easymotion'
endif

" depending on filetypes
Plug 'plasticboy/vim-markdown', {'for': 'mkd'}
Plug 'derekwyatt/vim-scala', {'for': 'scala', 'on': 'SortScalaImports'}
Plug 'fatih/vim-go', {'for': 'go'}
Plug 'vim-ruby/vim-ruby', {'for': 'ruby'}
" Plug 'scrooloose/syntastic'

" This doesn't fit into the strategy of new editors.
" Plug 'scrooloose/nerdtree', {'on': ['NERDTreeToggle', 'NERDTreeFind', 'NERDTreeFromBookmark', 'NERDTreeCWD']}

" This provides slower way to refactor than vim's built-in functions.
" Plug 'terryma/vim-multiple-cursors'

" The files *.sbt should be dealed as the files *.scala.
" Plug 'derekwyatt/vim-sbt', {'for': 'sbt'}

" It can't be an alternatie of git log command.
" Plug 'gregsexton/gitv'

" Plug 'Shougo/unite.vim'
" Plug 'Shougo/neomru.vim'
" Plug 'Shougo/unite-outline'
" Plug 'Shougo/vimproc.vim'

" Plug 'tacahiroy/ctrlp-funky'
" Plug 'vim-scripts/AutoComplPop'
" Plug 'scrooloose/nerdcommenter'
" Plug 'mikewest/vimroom'
" Plug 'nathanaelkane/vim-indent-guides'
" Plug 'godlygeek/tabular'
" Plug 'itchyny/lightline.vim'
" Plug 'mhinz/vim-startify'
" Plug 'tomasr/molokai'
" Plug 'dag/vim2hs', {'for': 'haskell'}
" Plug 'tpope/vim-fireplace', {'for': 'clojure'}

" local configuration for plugins
if filereadable(expand('~/.vimrc.bundles.local'))
    source ~/.vimrc.bundles.local
endif

call plug#end()

"----------------------------------------------------------------
" unite
"----------------------------------------------------------------
"let g:unite_enable_start_insert = 1
"let g:unite_source_history_yank_enable = 1
"let g:unite_source_file_mru_limit = 200
"if executable('ag')
    "let g:unite_source_rec_async_command =
    "\ 'ag --follow --nocolor --nogroup --hidden -g ""'
"elseif executable('git')
    "let g:unite_source_rec_async_command =
    "\ 'git ls-files . --cached --exclude-standard --others'
"endif
"nnoremap <Space>p :Unite file_rec/git:--cached:--others:--exclude-standard<CR>
"nnoremap <Space>p :Unite file_rec/async<CR>
"nnoremap <Space>b :Unite buffer<CR>
"nnoremap <Space>c :Unite command<CR>
"nnoremap <Space>s :Unite source<CR>
"nnoremap <Space>f :Unite function<CR>
"nnoremap <Space>m :Unite file_mru<CR>
"nnoremap <Space>l :Unite line<CR>
"nnoremap <Space>y :Unite history/yank<CR>
"nnoremap <Space>h :Unite change<CR>
"nnoremap <Space>n :Unite neobundle<CR>
"nnoremap <Space>r :Unite outline<CR>
"nnoremap <Space>j :Unite jump<CR>
"nnoremap <Space>k :Unite mapping<CR>

"----------------------------------------------------------------
" incsearch
"----------------------------------------------------------------
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)

"----------------------------------------------------------------
" syntastic
"----------------------------------------------------------------
let g:syntastic_mode_map = { "mode": "passive",
                        \ "active_filetypes": [],
                        \ "passive_filetypes": [] }
let g:syntastic_check_on_open = 1
let g:syntastic_enable_signs = 1
nnoremap <silent> <Leader>si :SyntasticInfo<CR>
nnoremap <silent> <Leader>sc :SyntasticCheck<CR>

"----------------------------------------------------------------
" nerdtree
"----------------------------------------------------------------
" nnoremap <silent> <Leader>nt :NERDTreeToggle<CR>
" nnoremap <silent> <Leader>nf :NERDTreeFind<CR>
" nnoremap <silent> <Leader>nm :NERDTreeMirror<CR>
" nnoremap <silent> <Leader>nb :NERDTreeFromBookmark<CR>
" nnoremap <silent> <Leader>nc :NERDTreeCWD<CR>

"----------------------------------------------------------------
" vimux
"----------------------------------------------------------------
" Some pane configuration
" let g:VimuxHeight = "45"
" let g:VimuxOrientation = "h"

nnoremap <silent> <Leader>vp :wa<CR>:VimuxPromptCommand<CR>
nnoremap <silent> <Leader>vl :wa<CR>:VimuxRunLastCommand<CR>
nnoremap <silent> <Leader>vi :VimuxInspectRunner<CR>
nnoremap <silent> <Leader>vq :VimuxCloseRunner<CR>
nnoremap <silent> <Leader>vs :VimuxInterruptRunner<CR>
nnoremap <silent> <Leader>vz :VimuxZoomRunner<CR>
nnoremap <silent> <Leader>vo :call VimuxOpenRunnerAtCWD()<CR>
nnoremap <silent> <Leader>vh :silent !tmux resize-pane -Z<CR>
function! VimuxOpenRunnerAtCWD()
    let cwd = getcwd()
    exe "normal! :VimuxRunCommand(\"" . cwd . "\")\<CR>"
endfunction

" aliases for sbt commands
nnoremap <silent> <Leader>vc :wa<CR>:VimuxRunCommand("compile")<CR>
nnoremap <silent> <Leader>vr :wa<CR>:VimuxRunCommand("run")<CR>
nnoremap <silent> <Leader>vt :call VimuxRunTest()<CR>

let g:lasttest = ""

function! VimuxRunTest()
    exe "normal! :wa\<CR>"
    let l:name = expand("%:t:r")
    let l:command = ""
    if l:name =~# "\.\*Test"
        let g:lasttest = l:name
        let l:command = "test:testOnly *" . l:name
    else
        let l:command = "test:testOnly *" . g:lasttest
    endif
    exe "normal! :call VimuxRunCommand(\"" . l:command . "\")\<CR>"
endfunction

"----------------------------------------------------------------
" indent-guides
"----------------------------------------------------------------
" let g:indent_guides_enable_on_vim_startup = 1
" let g:indent_guides_start_level = 2
" let g:indent_guides_guide_size = 1

"----------------------------------------------------------------
" tagbar
"----------------------------------------------------------------
let g:tagbar_type_scala = {
    \ 'ctagstype' : 'Scala',
    \ 'kinds'     : [
        \ 'p:packages:1',
        \ 'V:values',
        \ 'v:variables',
        \ 'T:types',
        \ 't:traits',
        \ 'o:objects',
        \ 'a:aclasses',
        \ 'c:classes',
        \ 'r:cclasses',
        \ 'm:methods'
    \ ]
\ }
nnoremap <leader>t :TagbarToggle<CR>

"----------------------------------------------------------------
" lightline
"----------------------------------------------------------------
"let g:lightline = {
      "\ 'colorscheme': 'solarized',
      "\ 'active': {
      "\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      "\   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      "\ },
      "\ 'component_function': {
      "\   'fugitive': 'MyFugitive',
      "\   'filename': 'MyFilename',
      "\   'fileformat': 'MyFileformat',
      "\   'filetype': 'MyFiletype',
      "\   'fileencoding': 'MyFileencoding',
      "\   'mode': 'MyMode',
      "\   'ctrlpmark': 'CtrlPMark',
      "\ },
      "\ 'component_expand': {
      "\   'syntastic': 'SyntasticStatuslineFlag',
      "\ },
      "\ 'component_type': {
      "\   'syntastic': 'error',
      "\ },
      "\ 'subseparator': { 'left': '|', 'right': '|' }
      "\ }

"function! MyModified()
  "return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
"endfunction

"function! MyReadonly()
  "return &ft !~? 'help' && &readonly ? 'RO' : ''
"endfunction

"function! MyFilename()
  "let fname = expand('%:t')
  "return fname == 'ControlP' ? g:lightline.ctrlp_item :
        "\ fname == '__Tagbar__' ? g:lightline.fname :
        "\ fname =~ '__Gundo\|NERD_tree' ? '' :
        "\ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        "\ &ft == 'unite' ? unite#get_status_string() :
        "\ &ft == 'vimshell' ? vimshell#get_status_string() :
        "\ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        "\ ('' != fname ? fname : '[No Name]') .
        "\ ('' != MyModified() ? ' ' . MyModified() : '')
"endfunction

"function! MyFugitive()
  "try
    "if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      "let mark = ''  " edit here for cool mark
      "let _ = fugitive#head()
      "return strlen(_) ? mark._ : ''
    "endif
  "catch
  "endtry
  "return ''
"endfunction

"function! MyFileformat()
  "return winwidth(0) > 70 ? &fileformat : ''
"endfunction

"function! MyFiletype()
  "return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
"endfunction

"function! MyFileencoding()
  "return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
"endfunction

"function! MyMode()
  "let fname = expand('%:t')
  "return fname == '__Tagbar__' ? 'Tagbar' :
        "\ fname == 'ControlP' ? 'CtrlP' :
        "\ fname == '__Gundo__' ? 'Gundo' :
        "\ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        "\ fname =~ 'NERD_tree' ? 'NERDTree' :
        "\ &ft == 'unite' ? 'Unite' :
        "\ &ft == 'vimfiler' ? 'VimFiler' :
        "\ &ft == 'vimshell' ? 'VimShell' :
        "\ winwidth(0) > 60 ? lightline#mode() : ''
"endfunction

"function! CtrlPMark()
  "if expand('%:t') =~ 'ControlP'
    "call lightline#link('iR'[g:lightline.ctrlp_regex])
    "return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          "\ , g:lightline.ctrlp_next], 0)
  "else
    "return ''
  "endif
"endfunction

"let g:ctrlp_status_func = {
  "\ 'main': 'CtrlPStatusFunc_1',
  "\ 'prog': 'CtrlPStatusFunc_2',
  "\ }

"function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  "let g:lightline.ctrlp_regex = a:regex
  "let g:lightline.ctrlp_prev = a:prev
  "let g:lightline.ctrlp_item = a:item
  "let g:lightline.ctrlp_next = a:next
  "return lightline#statusline(0)
"endfunction

"function! CtrlPStatusFunc_2(str)
  "return lightline#statusline(0)
"endfunction

"let g:tagbar_status_func = 'TagbarStatusFunc'

"function! TagbarStatusFunc(current, sort, fname, ...) abort
    "let g:lightline.fname = a:fname
  "return lightline#statusline(0)
"endfunction

"augroup AutoSyntastic
  "autocmd!
  "autocmd BufWritePost *.c,*.cpp call s:syntastic()
"augroup END
"function! s:syntastic()
  "SyntasticCheck
  "call lightline#update()
"endfunction

"let g:unite_force_overwrite_statusline = 0
"let g:vimfiler_force_overwrite_statusline = 0
"let g:vimshell_force_overwrite_statusline = 0

"----------------------------------------------------------------
" airline
"----------------------------------------------------------------
" theme
let g:airline_theme = "understated"

" customization
" let g:airline_powerline_fonts=1
" if !exists('g:airline_symbols')
"     let g:airline_symbols = {}
" endif
" let g:airline_left_sep = '»'
" let g:airline_left_sep = '▶'
" let g:airline_right_sep = '«'
" let g:airline_right_sep = '◀'
" let g:airline_symbols.linenr = '␊'
" let g:airline_symbols.linenr = '␤'
" let g:airline_symbols.linenr = '¶'
" let g:airline_symbols.branch = '⎇'
" let g:airline_symbols.paste = 'ρ'
" let g:airline_symbols.paste = 'Þ'
" let g:airline_symbols.paste = '∥'
" let g:airline_symbols.whitespace = 'Ξ'
let g:airline_left_sep = ''
let g:airline_right_sep = ''

" tabline
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#show_tab_nr = 1
let g:airline#extensions#tabline#tab_nr_type = 1
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#tabline#buffer_idx_mode = 1
let g:airline#extensions#tabline#fnamemod = ':t'
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9

"----------------------------------------------------------------
" multiple-cursors
"----------------------------------------------------------------
" function! Multiple_cursors_before()
"     if exists(':NeoCompleteLock')==2
"         exe 'NeoCompleteLock'
"     endif
" endfunction
" function! Multiple_cursors_after()
"     if exists(':NeoCompleteUnlock')==2
"         exe 'NeoCompleteUnlock'
"     endif
" endfunction

"----------------------------------------------------------------
" vim-scala
"----------------------------------------------------------------
nnoremap <silent> <Leader>ss :SortScalaImports<CR>
let g:scala_sort_across_groups=0

"----------------------------------------------------------------
" ycm
"----------------------------------------------------------------
let g:ycm_complete_in_comments = 1
let g:ycm_complete_in_strings = 1
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_seed_identifiers_with_syntax = 1

"----------------------------------------------------------------
" neocomplete
"----------------------------------------------------------------
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_auto_delimiter = 0
let g:neocomplete#sources#syntax#min_keyword_length = 4
let g:neocomplete#auto_completion_start_length = 2
if !exists('g:neocomplete#sources')
    let g:neocomplete#sources = {}
endif
let g:neocomplete#sources._ = ['buffer', 'neosnippet']
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"

"----------------------------------------------------------------
" neosnippet
"----------------------------------------------------------------
" imap <c-k> <Plug>(neosnippet_expand_or_jump)
" smap <c-k> <Plug>(neosnippet_expand_or_jump)
" xmap <c-k> <Plug>(neosnippet_expand_target)
" let g:neosnippet#snippets_directory = '~/.vim/bundle/neosnippet-snippets/neosnippets'
"imap <expr><tab> neosnippet#expandable_or_jumpable() ?
            "\ "\<Plug>(neosnippet_expand_or_jump)"
            "\: pumvisible() ? "\<c-n>" : "\<tab>"
"smap <expr><tab> neosnippet#expandable_or_jumpable() ?
            "\ "\<Plug>(neosnippet_expand_or_jump)"
            "\: "\<tab>"

"----------------------------------------------------------------
" ultisnips
"----------------------------------------------------------------
let g:UltiSnipsListSnippets="<c-tab>"
let g:UltiSnipsExpandTrigger="<c-j>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsSnippetsDir="~/.vim/bundle/vim-snippets/snippets"

"----------------------------------------------------------------
" vim-instant-markdown
"----------------------------------------------------------------
let g:instant_markdown_slow = 1
let g:instant_markdown_autostart = 0

"----------------------------------------------------------------
" startify
"----------------------------------------------------------------
" let g:startify_enable_special         = 0
" let g:startify_files_number           = 8
" let g:startify_relative_path          = 1
" let g:startify_change_to_dir          = 0
" let g:startify_session_autoload       = 1
" let g:startify_session_persistence    = 1
" let g:startify_session_delete_buffers = 1

" let g:startify_list_order = [
"   \ ['   LRU within this dir:'],
"   \ 'dir',
"   \ ['   LRU:'],
"   \ 'files',
"   \ ['   Sessions:'],
"   \ 'sessions',
"   \ ['   Bookmarks:'],
"   \ 'bookmarks',
"   \ ]

" let g:startify_skiplist = [
"             \ 'COMMIT_EDITMSG',
"             \ $VIMRUNTIME .'/doc',
"             \ 'bundle/.*/doc',
"             \ '\.vimgolf',
"             \ ]

" let g:startify_bookmarks = [
"             \ '~/.vimrc',
"             \ ]

" " let g:startify_custom_footer =
" "       \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

" let g:startify_custom_header =
"       \ map(split(system('tips | cowsay -f apt'), '\n'), '"   ". v:val') + ['']

" hi StartifyBracket ctermfg=240
" hi StartifyFile    ctermfg=147
" hi StartifyFooter  ctermfg=240
" hi StartifyHeader  ctermfg=114
" hi StartifyNumber  ctermfg=215
" hi StartifyPath    ctermfg=245
" hi StartifySlash   ctermfg=240
" hi StartifySpecial ctermfg=240

" nnoremap [Leader]s :Startify<CR>

"----------------------------------------------------------------
" foldElse (original plugin)
"----------------------------------------------------------------
" let s:pattern = ""
" "useful unfolding mapping
" nnoremap <Leader>fu zE

" nnoremap <Leader>fl :call FoldElseLastPattern()<CR>
" function! FoldElseLastPattern()
"     exe ":normal! :call FoldElse(\"" . s:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>fc :call FoldElseClass()<CR>
" function! FoldElseClass()
"     let l:pattern = "\\\\sclass\\\\s"
"     let s:pattern = l:pattern
"     exe ":normal! :call FoldElse(\"" . l:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>ff :call FoldElseFunc()<CR>
" function! FoldElseFunc()
"     let l:pattern = "\\\\sdef\\\\s"
"     let s:pattern = l:pattern
"     exe ":normal! :call FoldElse(\"" .l:pattern . "\")\<CR>"
" endfunction

" nnoremap <Leader>fp :call FoldElsePrompt()<CR>
" function! FoldElsePrompt()
"     let l:pattern = input("Pattern? ")
"     let s:pattern = l:pattern
"     exe "normal! :call FoldElse(\"" . l:pattern . "\")\<CR>"
" endfunction

" function! FoldElse(pattern)
"     set foldopen-=search
"     if search(a:pattern)
"         exe "normal! zEgg"
"         let l:flag = 0
"         let l:start_line_number = 0
"         while 1
"             let l:line_number = search(a:pattern, 'W')
"             if l:line_number == 0
"                 let l:line_number = line('$') + 1
"                 let l:flag = 1
"             endif
"             let l:end_line_number = l:line_number - 1
"             exe "normal! :" . l:start_line_number . "," . l:end_line_number . "fold\<CR>"
"             let l:start_line_number = l:line_number + 1
"             exe "normal! j"
"             if l:flag
"                 break
"             endif
"         endwhile
"         exe "normal! /" . a:pattern . "\<CR>"
"     endif
" endfunction
