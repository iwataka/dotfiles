"----------------------------------------------------------------
" Loading plugins
"----------------------------------------------------------------
" If using Windows Vim, you should manually add .vim directory to runtime path.
if has("win32") || has("win64")
    set runtimepath+=~/.vim/
endif

call plug#begin('~/.vim/bundle')

" auto completion (depending on OS type)
if (has("win32") || has("win64") || has("win32unix")) && has("lua")
    Plug 'Shougo/neocomplete.vim'
    Plug 'Shougo/neosnippet.vim'
    Plug 'Shougo/neosnippet-snippets'
elseif has('unix') && has("python")
    Plug 'Valloric/YouCompleteMe'
    Plug 'SirVer/ultisnips'
    " my fork repository to power scala support.
    Plug 'iwataka/vim-snippets'
else
    Plug 'ervandew/supertab'
endif

" cooperation with vimux (in gui only)
if !has('gui_running')
    Plug 'benmills/vimux'
    Plug 'christoomey/vim-tmux-navigator'
endif

" This plugin is unstable with nerdtree.
Plug 'tpope/vim-fugitive'

" Save the time to add close brackets.
Plug 'Raimondi/delimitMate'

" ctrlp and fast matcher
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'iwataka/ctrlproj.vim'

" useful key-mappings
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-commentary'

" motion helper
Plug 'haya14busa/incsearch.vim'

" display useful information
Plug 'airblade/vim-gitgutter'
Plug 'itchyny/lightline.vim'
Plug 'majutsushi/tagbar'

" Currently unused

" depending on filetypes
Plug 'plasticboy/vim-markdown', {'for': 'mkd'}
Plug 'derekwyatt/vim-scala', {'for': 'scala', 'on': 'SortScalaImports'}
Plug 'fatih/vim-go', {'for': 'go'}
Plug 'vim-ruby/vim-ruby', {'for': 'ruby'}
Plug 'scrooloose/syntastic', {'for': ['ruby', 'python']}
Plug 'tpope/vim-endwise', {'for': ['ruby', 'vim']}

" The files *.sbt should be dealed as the files *.scala.
" Plug 'derekwyatt/vim-sbt', {'for': 'sbt'}

" It can't be an alternatie of git log command.
" Plug 'gregsexton/gitv'

" Plug 'Shougo/vimproc.vim'

" Plug 'tacahiroy/ctrlp-funky'
" Plug 'vim-scripts/AutoComplPop'
" Plug 'scrooloose/nerdcommenter'
" Plug 'mikewest/vimroom'
" Plug 'godlygeek/tabular'
" Plug 'mhinz/vim-startify'
" Plug 'tomasr/molokai'
" Plug 'dag/vim2hs', {'for': 'haskell'}
" Plug 'tpope/vim-fireplace', {'for': 'clojure'}

" local configuration for plugins
if filereadable(expand('~/.vimrc.bundles.local'))
    source ~/.vimrc.bundles.local
endif

call plug#end()

"----------------------------------------------------------------
" autocompletion and snippets
"----------------------------------------------------------------
if (has("win32") || has("win64") || has("win32unix")) && has("lua")
    " neocomplete
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_auto_delimiter = 0
    let g:neocomplete#sources#syntax#min_keyword_length = 4
    let g:neocomplete#auto_completion_start_length = 2
    if !exists('g:neocomplete#sources')
        let g:neocomplete#sources = {}
    endif
    let g:neocomplete#sources._ = ['buffer', 'neosnippet']
    inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"
    " neosnippet
    imap <c-k> <Plug>(neosnippet_expand_or_jump)
    smap <c-k> <Plug>(neosnippet_expand_or_jump)
    xmap <c-k> <Plug>(neosnippet_expand_target)
    let g:neosnippet#snippets_directory = '~/.vim/bundle/neosnippet-snippets/neosnippets'
    imap <expr><tab> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: pumvisible() ? "\<c-n>" : "\<tab>"
    smap <expr><tab> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: "\<tab>"
elseif has('unix') && has("python")
    " ycm
    let g:ycm_complete_in_comments = 1
    let g:ycm_complete_in_strings = 1
    let g:ycm_collect_identifiers_from_comments_and_strings = 1
    let g:ycm_collect_identifiers_from_tags_files = 1
    let g:ycm_seed_identifiers_with_syntax = 1
    let g:ycm_key_detailed_diagnostics = ''
    " ultisnips
    let g:UltiSnipsListSnippets="<c-tab>"
    let g:UltiSnipsExpandTrigger="<c-j>"
    let g:UltiSnipsJumpForwardTrigger="<c-j>"
    let g:UltiSnipsJumpBackwardTrigger="<c-k>"
    let g:UltiSnipsSnippetsDir="~/.vim/bundle/vim-snippets/snippets"
endif

"----------------------------------------------------------------
" ctrlp
"----------------------------------------------------------------
if executable('ag')
    let g:ctrlp_user_command = 'ag --follow --nocolor -g "" %s'
elseif executable('ack')
    let g:ctrlp_user_command = 'ack --follow --nocolor -g "" %s'
endif

" default ignored directories
let g:ctrlp_custom_ignore = {
    \ 'dir': '\.gradle$\|build$\|project$\|target$\|out$\|libs$\|\.git$',
    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS'
\ }
let g:ctrlp_cmd = 'CtrlP .'
let g:ctrlp_working_path_mode='wr'
let g:ctrlp_by_filename = 0
let g:ctrlp_show_hidden = 1
let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:20'

" use pymatcher
if !has('python')
    echo 'In order to use pymatcher plugin, you need +python compiled vim'
else
    let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif

" fast aliases for ctrlp
nnoremap <silent> <Leader>p :CtrlP .<CR>
nnoremap <silent> <Leader>b :CtrlPBuffer<CR>
nnoremap <silent> <Leader>m :CtrlPMRU<CR>
nnoremap <silent> <Leader>q :Ctrlproj<CR>
nnoremap <silent> <Leader>l :CtrlprojLastDir<CR>
nnoremap <silent> <leader>x :CtrlprojVSwitch<cr>
nnoremap <silent> <leader>a :CtrlprojVAlternate<cr>
nnoremap <silent> <leader>d :CtrlpDir<cr>
" below three mappings is less frequently used
" nnoremap <silent> <Leader>l :CtrlPLine %<CR>
" nnoremap <silent> <Leader>u :CtrlPUndo<CR>
" nnoremap <silent> <Leader>r :CtrlPFunky<CR>

"----------------------------------------------------------------
" fugitive
"----------------------------------------------------------------
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gg :Ggrep<Space>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gr :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gl :Glog<CR>
" 'h' is the abbreviation of 'history'
nnoremap <Leader>gh :!git log<cr>

"----------------------------------------------------------------
" incsearch
"----------------------------------------------------------------
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)

"----------------------------------------------------------------
" syntastic
"----------------------------------------------------------------
let g:syntastic_mode_map = { "mode": "passive",
                        \ "active_filetypes": [],
                        \ "passive_filetypes": [] }
let g:syntastic_check_on_open = 1
let g:syntastic_enable_signs = 1
nnoremap <silent> <Leader>si :SyntasticInfo<CR>
nnoremap <silent> <Leader>sc :SyntasticCheck<CR>

"----------------------------------------------------------------
" vimux
"----------------------------------------------------------------
" Some pane configuration
" let g:VimuxHeight = "45"
" let g:VimuxOrientation = "h"

nnoremap <silent> <Leader>vp :wa<CR>:VimuxPromptCommand<CR>
nnoremap <silent> <Leader>vl :wa<CR>:VimuxRunLastCommand<CR>
nnoremap <silent> <Leader>vi :VimuxInspectRunner<CR>
nnoremap <silent> <Leader>vq :VimuxCloseRunner<CR>
nnoremap <silent> <Leader>vs :VimuxInterruptRunner<CR>
nnoremap <silent> <Leader>vz :VimuxZoomRunner<CR>
nnoremap <silent> <Leader>vo :call VimuxOpenRunnerAtCWD()<CR>
nnoremap <silent> <Leader>vh :silent !tmux resize-pane -Z<CR>
function! VimuxOpenRunnerAtCWD()
    let cwd = getcwd()
    exe "normal! :VimuxRunCommand(\"" . cwd . "\")\<CR>"
endfunction

" aliases for sbt commands
nnoremap <silent> <Leader>vc :wa<CR>:VimuxRunCommand("compile")<CR>
nnoremap <silent> <Leader>vr :wa<CR>:VimuxRunCommand("run")<CR>
nnoremap <silent> <Leader>vt :call VimuxRunTest()<CR>

let g:lasttest = ""

function! VimuxRunTest()
    exe "normal! :wa\<CR>"
    let l:name = expand("%:t:r")
    let l:command = ""
    if l:name =~# "\.\*Test"
        let g:lasttest = l:name
        let l:command = "test:testOnly *" . l:name
    else
        let l:command = "test:testOnly *" . g:lasttest
    endif
    exe "normal! :call VimuxRunCommand(\"" . l:command . "\")\<CR>"
endfunction

"----------------------------------------------------------------
" tagbar
"----------------------------------------------------------------
let g:tagbar_type_scala = {
    \ 'ctagstype' : 'Scala',
    \ 'kinds'     : [
        \ 'p:packages:1',
        \ 'V:values',
        \ 'v:variables',
        \ 'T:types',
        \ 't:traits',
        \ 'o:objects',
        \ 'a:aclasses',
        \ 'c:classes',
        \ 'r:cclasses',
        \ 'm:methods'
    \ ]
\ }
nnoremap <leader>t :TagbarToggle<CR>

"----------------------------------------------------------------
" gitgutter
"----------------------------------------------------------------
" let g:gitgutter_sign_added = '✚'
" let g:gitgutter_sign_modified = '➜'
" let g:gitgutter_sign_removed = '✘'

"----------------------------------------------------------------
" lightline
"----------------------------------------------------------------
let g:lightline = {
    \ 'colorscheme': 'solarized',
    \ 'active': {
    \   'left': [
    \       ['mode', 'paste'],
    \       ['gitgutter', 'fugitive'],
    \       ['filename', 'modified', 'readonly']
    \   ],
    \   'right': [
    \       ['lineinfo', 'syntastic'],
    \       ['percent'],
    \       ['charcode', 'fileformat', 'fileencoding', 'filetype']
    \   ]
    \ },
    \ 'component_function': {
    \   'syntastic': 'SyntasticStatuslineFlag',
    \   'gitgutter': 'MyGitGutter',
    \   'fugitive': 'MyFugitive',
    \   'modified': 'MyModified',
    \   'readonly': 'MyReadOnly'
    \ }
    \ }

let g:ctrlp_buffer_func = {'enter': 'CtrlPEnter'}
function! CtrlPEnter()
    let w:lightline = 0
endfunction

function! MyFugitive()
    if exists('*fugitive#statusline')
        retu fugitive#statusline()
    endif
endfunction

function! MyReadOnly()
    if &readonly
        retu 'RO'
    else
        retu ''
    endif
endfunction

function! MyModified()
    if &modified
        retu '[+]'
    else
        retu ''
    endif
endfunction

function! MyGitGutter()
    if !exists('*GitGutterGetHunkSummary')
            \ || !get(g:, 'gitgutter_enabled', 0)
            \ || winwidth('.') <= 90
        return ''
    en
    let symbols = [
        \ g:gitgutter_sign_added . ' ',
        \ g:gitgutter_sign_modified . ' ',
        \ g:gitgutter_sign_removed . ' '
        \ ]
    let hunks = GitGutterGetHunkSummary()
    let ret = []
    for i in [0, 1, 2]
        call add(ret, symbols[i].hunks[i])
    endfo
    return join(ret, ' ')
endf

"----------------------------------------------------------------
" vim-scala
"----------------------------------------------------------------
nnoremap <silent> <Leader>ss :SortScalaImports<CR>
let g:scala_sort_across_groups=0
